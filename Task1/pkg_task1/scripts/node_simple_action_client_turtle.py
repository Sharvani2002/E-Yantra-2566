#!/usr/bin/env python

# ROS Node - Simple Action Client - Turtle

import rospy
import actionlib
import time
import requests

from turtlesim.msg import Pose
from geometry_msgs.msg import Twist

from pkg_task1.msg import myActionMsgAction       # Message Class that is used by ROS Actions internally
from pkg_task1.msg import myActionMsgGoal         # Message Class that is used for Goal messages
from pkg_task1.msg import myActionMsgResult       # Message Class that is used for Result messages
from pkg_task1.msg import myActionMsgFeedback     # Message Class that is used for F

from pkg_ros_iot_bridge.msg import msgRosIotAction      # Message Class that is used by ROS Actions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal        # Message Class that is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult      # Message Class that is used for Result Messages

from pkg_ros_iot_bridge.msg import msgMqttSub

# import paho.mqtt.client as mqtt
# 
# def on_connect(client, userdata, flags, rc):  # The callback for when the client connects to the broker
#     print "Connected with result code {0}".format(str(rc)) # Print result of connection attempt
#     client.subscribe("eyrc/rSnNRsNn/iot_to_ros", qos=0)

# def on_message(client, userdata, msg):  # The callback for when a PUBLISH message is received from the server.
#     print("Message received-> " + msg.topic + " " + str(msg.payload))  # Print a received msg
#     if(str(msg.payload) == str("start")):
#         return 1
#     else:
#         return 0

def mqtt_sub_callback(message):
    payload = str(message.message.decode("utf-8"))
    global mqtt_return
    mqtt_return=0
    print("[MQTT SUB CB] Message: ", payload)
    print("[MQTT SUB CB] Topic: ", message.topic)

    # msg_mqtt_sub = msgMqttSub()
    # msg_mqtt_sub.timestamp = rospy.Time.now()
    # msg_mqtt_sub.topic = message.topic
    # msg_mqtt_sub.message = payload
    if((str(payload) == "start") or (str(payload) == "Start")):
        mqtt_return=1
    else:
        mqtt_return=0

class RosIotBridgeActionClient:

    # Constructor
    def __init__(self):

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot',
                                          msgRosIotAction)
        
        # Dictionary to Store all the goal handles
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_pyiot')
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']

        # Wait for Action Server that will use the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    
    # This function will be called when there is a change of state in the Action Client State Machine
    def on_transition(self, goal_handle):
        
        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.
        
        result = msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()) )
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()) )
        
        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done
        
        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        
        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            
            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if (result.flag_success == True):
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))

    def mqtt_sub_callback(self, client, userdata, message):
        payload = str(message.payload.decode("utf-8"))

        print("[MQTT SUB CB] Message: ", payload)
        print("[MQTT SUB CB] Topic: ", message.topic)

        # msg_mqtt_sub = msgMqttSub()
        # msg_mqtt_sub.timestamp = rospy.Time.now()
        # msg_mqtt_sub.topic = message.topic
        # msg_mqtt_sub.message = payload
        if((str(payload) != "start") or (str(payload) != "Start")):
            sleep(1)

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")
        
        # self.on_transition - It is a function pointer to a function which will be called when 
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)

        return goal_handle

class SimpleActionClientTurtle:

    # Constructor
    def __init__(self):
        self._ac = actionlib.SimpleActionClient('/action_turtle',
                                                myActionMsgAction)
        self._ac.wait_for_server()
        rospy.loginfo("Action server is up, we can send new goals!")

    # Function to send Goals to Action Servers
    def send_goal(self, arg_dis, arg_angle):
        
        # Create Goal message for Simple Action Server
        goal = myActionMsgGoal(distance=arg_dis, angle=arg_angle)
        
        '''
            * done_cb is set to the function pointer of the function which should be called once 
                the Goal is processed by the Simple Action Server.

            * feedback_cb is set to the function pointer of the function which should be called while
                the goal is being processed by the Simple Action Server.
        ''' 
        self._ac.send_goal(goal, done_cb=self.done_callback,
                           feedback_cb=self.feedback_callback)
        
        rospy.loginfo("Goal has been sent.")

    # Function print result on Goal completion
    def push_sheets(self,fx,fy,ft):
        parameters = {"id":"task1", "team_id":"VB_2566", "unique_id":"rSnNRsNn", "turtle_x":fx, "turtle_y":fy, "turtle_theta":ft} 
        URL2 = "https://script.google.com/macros/s/AKfycbzShBXxDAmHipGUVOBcP3OfhMabCBxfZD2dvvn0Abbw0Z84_PJu/exec"
        response = requests.get(URL2, params=parameters)
        print(response.content)

    def done_callback(self, status, result):
        rospy.loginfo("Status is : " + str(status))
        rospy.loginfo("Result is : " + str(result))
        # final_x=result.final_x
        # final_y=result.final_y
        # final_theta = result.final_theta
        # push_sheets(result.final_x,result.final_y,result.final_theta)
        parameters = {"id":"task1", "team_id":"VB_2566", "unique_id":"rSnNRsNn", "turtle_x":result.final_x, "turtle_y":result.final_y, "turtle_theta":result.final_theta} 
        URL2 = "https://script.google.com/macros/s/AKfycbzShBXxDAmHipGUVOBcP3OfhMabCBxfZD2dvvn0Abbw0Z84_PJu/exec"
        response = requests.get(URL2, params=parameters)
        print(response.content)
        #publish_mqtt(result.final_x,result.final_y,result.final_theta)
        action_client = RosIotBridgeActionClient()

        goal_handle1 = action_client.send_goal("mqtt", "pub", action_client._config_mqtt_pub_topic, str(result))
        action_client._goal_handles['1'] = goal_handle1
        rospy.loginfo("Goal #1 Sent")

    # Function to print feedback while Goal is being processed
    def feedback_callback(self, feedback):
        rospy.loginfo(feedback)


# Main Function
def main():
    # 1. Initialize ROS Node
    rospy.init_node('node_simple_action_client_turtle')

    # 2. Create a object for Simple Action Client.
    obj_client = SimpleActionClientTurtle()

    # pub = rospy.Publisher("eyrc/rSnNRsNn/ros_to_iot","success:", queue_size=10)

    #action client part
    action_client = RosIotBridgeActionClient()

    # goal_handle1 = action_client.send_goal("mqtt", "pub", action_client._config_mqtt_pub_topic, "Hello from Action Client!")
    # action_client._goal_handles['1'] = goal_handle1
    # rospy.loginfo("Goal #1 Sent")

    # goal_handle2 = action_client.send_goal("mqtt", "sub", "/eyrc/rSnNRsNn/iot_to_ros", "NA")
    # action_client._goal_handles['2'] = goal_handle2
    # rospy.loginfo("Goal #2 Sent")
    #action client part

    # rospy.sleep(1.0)
    # goal_handle1.cancel()

    rate = rospy.Rate(5)

    # broker_url = "broker.mqttdashboard.com"
    # broker_port = 1883

    # client = mqtt.Client()
    # client.connect(broker_url, broker_port)

    #client.subscribe("eyrc/rSnNRsNn/iot_to_ros", qos=0)
    # client.on_connect = on_connect  # Define callback function for successful connection
    # client.on_message = on_message  # Define callback function for receipt of a message
    #client.publish(topic="eyrc/rSnNRsNn/ros_to_iot", payload="Success", qos=0, retain=False)
    mqtt_sub = rospy.Subscriber("/ros_iot_bridge/mqtt/sub", msgMqttSub, mqtt_sub_callback)
    global mqtt_return
    mqtt_return = 0
    # goal_handle2 = action_client.send_goal("mqtt", "sub", "eyrc/rSnNRsNn/iot_to_ros", msgMqttSub().message)
    # action_client._goal_handles['2'] = goal_handle2
    # rospy.loginfo("Goal #2 Sent")
    while not rospy.is_shutdown():

        if(mqtt_return==1):
            obj_client.send_goal(2, 0)
            rospy.sleep(10)
            
            obj_client.send_goal(2,60)
            rospy.sleep(10)

            obj_client.send_goal(2, 60)
            rospy.sleep(10)

            obj_client.send_goal(2, 60)
            rospy.sleep(10)

            obj_client.send_goal(2, 60)
            rospy.sleep(10)
            
            obj_client.send_goal(2,60)
            rospy.sleep(10)
            rospy.spin()

    # msg_mqtt_sub = msgMqttSub()
    # msg_mqtt_sub.timestamp = rospy.Time.now()
    # msg_mqtt_sub.topic = message.topic
    # msg_mqtt_sub.message = payload

if __name__ == '__main__':
    main()

# ROS Node - Action Client - IoT ROS Bridge



    

